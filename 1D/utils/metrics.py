import torch
import logging
from typing import Dict, List, Tuple
from data.generate_burgers import burgers_numeric_solve_free
import pdb
import time

def evaluate_samples(
    diffused: torch.Tensor,
    u_controlled: torch.Tensor,
    u_target: torch.Tensor,
    nt: int,
    u_bound: float,
    use_max_safety: bool = True
) -> Dict[str, float]:
    """Evaluate generated samples against ground truth
    
    Args:
        diffused: Samples generated by diffusion model, shape (batch, channels, time, space), unscaled, GPU
        u_controlled: State trajectories from solver, shape (batch, original_time, space), unscaled, GPU
        u_target: Ground truth trajectories, shape (batch, original_time, space), unscaled, GPU
        u_bound: Safety bound for state values
        
    Returns:
        Dictionary containing evaluation metrics
    """
    metrics = {}
    
    diffused_u = diffused[:, 0, :nt, :]  # State sequence
    diffused_s = diffused[:, 2, :nt, :]  # safety score
    
    control_mse = (u_target[:, -1, :] - u_controlled[:, -1, :]).square().mean((-1))
    metrics['control_mse_mean (J)'] = control_mse.mean().item()
    metrics['control_mse_std'] = control_mse.std().item()
    # print("per sample control performance: ", control_mse)
    
    safety_metrics = calculate_safety_metrics(u_controlled, u_bound, diffused_s, use_max_safety)
    metrics.update(safety_metrics)
    
    return metrics

def control_trajectories(diffused: torch.Tensor, nt: int) -> torch.Tensor:
    """Generate controlled trajectories using solver
    
    Args:
        diffused: Diffusion model output, (batch, channels, padded_time, space), unscaled, GPU
        
    Returns:
        Controlled state trajectories from solver, (batch, original_time, space), unscaled, GPU
    """
    # Extract initial state and control sequence
    diffused_u = diffused[:, 0, :nt, :]
    diffused_f = diffused[:, 1, :nt-1, :]

    # Solve Burgers equation with control
    u_controlled = burgers_numeric_solve_free(
        diffused_u[:, 0, :],  # Initial state
        diffused_f,           # Control force
        visc=0.01,           # Viscosity
        T=1.0,               # Total time
        dt=1e-4,             # Time step
        num_t=10             # Number of time steps
    )

    return u_controlled

def calculate_safety_metrics(u: torch.Tensor, threshold: float, diffused_s: torch.Tensor, use_max_safety: bool = True) -> Dict[str, float]:
    """Calculate safety metrics
    Args:
        u: Controlled state trajectory
        threshold: Safety threshold for u
    Returns:
        Dictionary containing safety metrics
    """
    metrics = {}
    
    exceed_mask = (u.abs() > threshold)
    
    # Statistics by value
    value_exceed = exceed_mask.float().mean()
    metrics['point_exceed_ratio (R_p)'] = value_exceed.item()
    
    # Statistics by time
    time_exceed = (exceed_mask.any(dim=-1)).float().mean()
    metrics['time_exceed_ratio (R_t)'] = time_exceed.item()
    
    # Statistics by sample
    sample_exceed = (exceed_mask.any(dim=(-1,-2))).float().mean()
    metrics['sample_exceed_ratio (R_s)'] = sample_exceed.item()

    sample_exceed_indices = exceed_mask.any(dim=(-1,-2)).nonzero(as_tuple=True)[0].tolist()
    metrics['sample_excedd_indices'] = sample_exceed_indices
    
    return metrics

def calculate_safety_score(u: torch.Tensor) -> torch.Tensor:
    """Calculate safety score
    
    Args:
        u: Input tensor
        
    Returns:
        Safety score
    """
    return (u.square()).amax((-1, -2))
